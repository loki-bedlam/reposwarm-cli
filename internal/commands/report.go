package commands

import (
	"fmt"
	"os"
	"strings"

	"github.com/loki-bedlam/reposwarm-cli/internal/api"
	"github.com/loki-bedlam/reposwarm-cli/internal/output"
	"github.com/spf13/cobra"
)

func newReportCmd() *cobra.Command {
	var outputFile string
	var sections string

	cmd := &cobra.Command{
		Use:   "report [repos...]",
		Short: "Generate investigation summary report",
		Long: `Generate a consolidated markdown report from investigation results.

Without repo names: reports on ALL repos with results.
With repo names: reports on specified repos only.

Examples:
  reposwarm report                          # All repos
  reposwarm report is-odd meshmart-catalog  # Specific repos
  reposwarm report -o report.md             # Save to file
  reposwarm report --sections hl_overview,apis  # Only certain sections`,
		RunE: func(cmd *cobra.Command, args []string) error {
			client, err := getClient()
			if err != nil {
				return err
			}

			// Get repos with results
			var repoList api.WikiReposResponse
			if err := client.Get(ctx(), "/wiki", &repoList); err != nil {
				return err
			}

			// Filter to requested repos
			var targetRepos []api.WikiRepoSummary
			if len(args) > 0 {
				nameSet := make(map[string]bool)
				for _, a := range args {
					nameSet[strings.ToLower(a)] = true
				}
				for _, r := range repoList.Repos {
					if nameSet[strings.ToLower(r.Name)] {
						targetRepos = append(targetRepos, r)
					}
				}
			} else {
				targetRepos = repoList.Repos
			}

			if len(targetRepos) == 0 {
				return fmt.Errorf("no repos with investigation results found")
			}

			// Parse section filter
			var sectionFilter map[string]bool
			if sections != "" {
				sectionFilter = make(map[string]bool)
				for _, s := range strings.Split(sections, ",") {
					sectionFilter[strings.TrimSpace(s)] = true
				}
			}

			if !flagJSON {
				output.Infof("Generating report for %d repos...", len(targetRepos))
			}

			// Build report
			var sb strings.Builder
			sb.WriteString("# RepoSwarm Investigation Report\n\n")
			sb.WriteString(fmt.Sprintf("Repos: %d | Generated by `reposwarm report`\n\n", len(targetRepos)))
			sb.WriteString("---\n\n")

			// Table of contents
			sb.WriteString("## Table of Contents\n\n")
			for i, r := range targetRepos {
				sb.WriteString(fmt.Sprintf("%d. [%s](#%s) (%d sections)\n", i+1, r.Name, strings.ReplaceAll(r.Name, " ", "-"), r.SectionCount))
			}
			sb.WriteString("\n---\n\n")

			type RepoReport struct {
				Name     string            `json:"name"`
				Sections int               `json:"sections"`
				Content  map[string]string `json:"content"`
			}
			var jsonReports []RepoReport

			for _, r := range targetRepos {
				sb.WriteString(fmt.Sprintf("# %s\n\n", r.Name))

				var index api.WikiIndex
				if err := client.Get(ctx(), "/wiki/"+r.Name, &index); err != nil {
					sb.WriteString(fmt.Sprintf("*Error loading sections: %s*\n\n", err))
					continue
				}

				jsonReport := RepoReport{Name: r.Name, Content: make(map[string]string)}

				for _, s := range index.Sections {
					if sectionFilter != nil && !sectionFilter[s.ID] {
						continue
					}

					var content api.WikiContent
					if err := client.Get(ctx(), "/wiki/"+r.Name+"/"+s.ID, &content); err != nil {
						continue
					}

					sb.WriteString(fmt.Sprintf("## %s\n\n", s.Label))
					sb.WriteString(content.Content)
					sb.WriteString("\n\n---\n\n")

					jsonReport.Content[s.ID] = content.Content
				}
				jsonReport.Sections = len(jsonReport.Content)
				jsonReports = append(jsonReports, jsonReport)
			}

			if flagJSON {
				return output.JSON(jsonReports)
			}

			report := sb.String()

			if outputFile != "" {
				if err := os.WriteFile(outputFile, []byte(report), 0644); err != nil {
					return fmt.Errorf("writing report: %w", err)
				}
				output.Successf("Report saved to %s (%d bytes, %d repos)", outputFile, len(report), len(targetRepos))
				return nil
			}

			fmt.Print(report)
			return nil
		},
	}

	cmd.Flags().StringVarP(&outputFile, "output", "o", "", "Output file path")
	cmd.Flags().StringVar(&sections, "sections", "", "Comma-separated section names to include")
	return cmd
}
